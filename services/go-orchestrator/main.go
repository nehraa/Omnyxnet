package goorchestrator
package main












































































































































}	}		log.Fatalf("‚ùå Error during shutdown: %v", err)	if err := orchestrator.Stop(); err != nil {	<-sigChan	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)	sigChan := make(chan os.Signal, 1)	// Setup signal handling for graceful shutdown	}		log.Fatalf("‚ùå Failed to start orchestrator: %v", err)	if err := orchestrator.Start(); err != nil {	orchestrator := NewOrchestrator(config)	}		GracefulShutdown: *gracefulShutdown,		MaxWorkers:       *maxWorkers,		ListenPort:       *listenPort,		RpcAddr:          *rpcAddr,		ID:               uint32(*id),	config := &OrchestratorConfig{	flag.Parse()	)		gracefulShutdown = flag.Duration("shutdown-timeout", 30*time.Second, "Graceful shutdown timeout")		maxWorkers       = flag.Int("max-workers", 10, "Maximum number of connected workers")		listenPort       = flag.String("listen", "0.0.0.0:8080", "Server listen address")		rpcAddr          = flag.String("rpc-addr", ":8080", "RPC server address")		id               = flag.Uint("id", 1, "Orchestrator node ID")	var (func main() {// main entry point}	return nil	log.Println("‚úÖ Orchestrator shutdown complete")	<-time.After(o.config.GracefulShutdown)	// Give in-flight requests time to complete		}		}			log.Printf("‚ö†Ô∏è  Error closing listener: %v", err)		if err := o.listener.Close(); err != nil {	if o.listener != nil {		o.cancel()	log.Println("üõë Shutting down orchestrator...")func (o *Orchestrator) Stop() error {// Stop gracefully shuts down the orchestrator}	// Actual message handling would occur here	log.Printf("üîå Handling connection from %s", conn.RemoteAddr())	defer conn.Close()func (o *Orchestrator) handleConnection(conn net.Conn) {// handleConnection processes a single client connection}	}		}			go o.handleConnection(conn)			// Handle connection in goroutine			log.Printf("‚úÖ New connection accepted from %s", conn.RemoteAddr())			}				continue				log.Printf("‚ö†Ô∏è  Failed to accept connection: %v", err)			if err != nil {			conn, err := o.listener.Accept()		default:			return			log.Println("üì§ Stopping connection acceptance")		case <-o.ctx.Done():		select {	for {func (o *Orchestrator) acceptConnections() {// acceptConnections accepts incoming client connections}	return nil	go o.acceptConnections()	// Simulate accepting connections (actual implementation would handle gRPC/Cap'n Proto)	log.Printf("‚è±Ô∏è  Graceful shutdown timeout: %v", o.config.GracefulShutdown)	log.Printf("ü§ù Max workers: %d", o.config.MaxWorkers)	log.Printf("üì° RPC server listening on %s", o.config.RpcAddr)	log.Printf("üöÄ Go Orchestrator started (ID: %d)", o.config.ID)	}		return fmt.Errorf("failed to listen on %s: %w", o.config.RpcAddr, err)	if err != nil {	o.listener, err = net.Listen("tcp", o.config.RpcAddr)	var err errorfunc (o *Orchestrator) Start() error {// Start initiates the RPC server and listens for connections}	}		gradientManager:  gradient.NewManager(),		cancel:           cancel,		ctx:              ctx,		config:           cfg,	return &Orchestrator{	ctx, cancel := context.WithCancel(context.Background())func NewOrchestrator(cfg *OrchestratorConfig) *Orchestrator {// NewOrchestrator creates a new orchestrator instance}	gradientManager *gradient.Manager	cancel          context.CancelFunc	ctx             context.Context	listener        net.Listener	config          *OrchestratorConfigtype Orchestrator struct {// Orchestrator represents the RPC server and coordination logic}	GracefulShutdown time.Duration	MaxWorkers  int	ListenPort  string	RpcAddr     string	ID          uint32type OrchestratorConfig struct {// OrchestratorConfig holds configuration for the orchestrator)	"github.com/pangea-net/go-orchestrator/pkg/gradient"	"time"	"syscall"	"os/signal"	"os"	"net"	"log"	"fmt"	"flag"	"context"import (