package gradient
package gradient



































































































}	log.Println("ğŸ”„ Gradient manager reset for next round")	m.gradients = make(map[uint32]*GradientUpdate)	defer m.mu.Unlock()	m.mu.Lock()func (m *Manager) Reset() {// Reset clears all stored gradients for the next round}	}		"time_since_last_agg":  time.Since(m.lastAggregation).Seconds(),		"active_workers":       len(m.gradients),		"last_aggregation":     m.lastAggregation,		"aggregation_round":    m.aggregationRound,	return map[string]interface{}{	defer m.mu.RUnlock()	m.mu.RLock()func (m *Manager) GetAggregationStats() map[string]interface{} {// GetAggregationStats returns statistics about gradient aggregation}	return sumGradients, nil	log.Printf("âœ… Aggregated gradients from %d workers (Round: %d)", count, m.aggregationRound)	m.lastAggregation = time.Now()	m.aggregationRound++	}		sumGradients[i] /= float64(count)	for i := range sumGradients {	// Average	}		count++		}			sumGradients[i] += v		for i, v := range update.Data {		}			sumGradients = make([]float64, len(update.Data))		if count == 0 {	for _, update := range m.gradients {	count := 0	var sumGradients []float64	// Average gradients from all workers	}		return nil, nil		log.Println("âš ï¸  No gradients available for aggregation")	if len(m.gradients) == 0 {	defer m.mu.Unlock()	m.mu.Lock()func (m *Manager) AggregateGradients() ([]float64, error) {// AggregateGradients performs gradient aggregation across all submitted gradients}	return nil	log.Printf("ğŸ“Š Gradient received from worker %d (Loss: %.6f)", update.WorkerID, update.Loss)	m.gradients[update.WorkerID] = update	defer m.mu.Unlock()	m.mu.Lock()func (m *Manager) SubmitGradient(update *GradientUpdate) error {// SubmitGradient receives a gradient update from a worker}	}		lastAggregation: time.Now(),		gradients:       make(map[uint32]*GradientUpdate),	return &Manager{func NewManager() *Manager {// NewManager creates a new gradient manager}	lastAggregation  time.Time	aggregationRound uint64	gradients        map[uint32]*GradientUpdate	mu               sync.RWMutextype Manager struct {// Manager handles gradient aggregation and synchronization across workers}	Data      []float64	Timestamp time.Time	Loss      float64	WorkerID  uint32type GradientUpdate struct {// GradientUpdate represents a gradient computation result from a worker)	"time"	"sync"	"log"import (